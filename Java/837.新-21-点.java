/*
 * @lc app=leetcode.cn id=837 lang=java
 *
 * [837] 新21点
 * 解题思路
 * 1、DP动态规划
 * 要知道不超过N分的概率，就要知道在获得K-1分之后，再抽取一次牌超过N的概率；
 * 例如：N=21，K=17，W=10的情况
 * 假设当前在16分的位置，再取一次就满足K=17，由于每次从W张牌里面抽取任意一张牌的概率是相同的1/W
 * 所以从16分的位置抽取一张牌可以分两种情况，
 * 一种是抽取1-5分相加的结果都不大于21，抽取1-5分的概率是1/W=1/10，这样不超过N的概率就是100%；
 * 一种是抽取6-10分相加的结果都大于21，抽取6-10不超过N的概率是0；
 * 那么在16分时，抽取不超过N分的概率是f(16)= (1+1+1+1+1+0+0+0+0+0)/10=0.5
 * 这个计算公式里面每个1都代表当前牌面值被抽取后不超过N的概率，0则相反；然后把每个的概率相加除以总数W就是当前的平均概率。
 * 有了f(16)再来推理下通用概率公式f(x)=(f(x+1)+f(x+2)...+f(x+w))/W
 * 由此我们在递推下f(15) = (f(16) + f(17) + ... f(26))/10 = (1/2 + 1 + 1 + 1 + 1 + 1 + 0 + 0 + 0 + 0)/10 = 0.55
 * 这样依次向前递推就可以得到f(0)的概率。
 * 
 * 验证：
 * N=10， K=1， W=10
 * 只取W中任意一个就达到1的界限，取值在1-10之间，而所有取值都不超过N,所以结果为f(0) = (1+1+1+1+1+1+1+1+1+1)/10 = 1
 * 
 * N = 6, K = 1, W = 10
 * f(0) = (1+1+1+1+1+1+0+0+0+0)/0.6
 * 
 * f(x)为递推公式，最终要取的值是f(0)
 * DP的长度 为K+W-1
 * 
 * 由于第一个代码的时间复杂度为O(N+KW)会超时需要优化，优化主要在O(KW)上进行
 * 由于相邻项是有关系的，比如：
 * d(x) = (d(x+1)+d(x+2)+...+d(x+W))/W
 * d(x+1) = (d(x+2)+d(x+3)+...+d(x+w+1))/W
 * 两者的差值在于 d(x)-d(x+1) = (d(x+1) - d(x+w+1))/W 当 0 <= x < K - 1
 * d(x) = d(x+1) + (d(x+1) - d(x+w+1))/W
 * 当 x = K - 1
 */

// @lc code=start
class Solution {
    public double new21Game(int N, int K, int W) {
        if (K == 0) {
            return 1.0;
        }
        // double的默认值是0.0，Double包装类的默认值是null
        double[] dp = new double[K + W];

        // 最后W个数的概率是明确的,但是对应的i可能超过N，超过的部分就不是1.0的结果了
        for (int i = K; i <= N && i < K + W; i++) {
            dp[i] = 1.0;
        }

        // K-1的结果是固定值，取值N-K+1表示N在[K，W]之间，取值W表示N>W，最大结果只能到W
        // N - (K - 1) 表示两个位置之间的数量，这个之间的每个值的概率都是1
        // 或者 K + W - 1 - (K - 1) 如果这个位置先达到，那么这中间的每个值的概率都是1
        // min(N，K + W -1) - (K - 1) => min(N - K + 1, W)
        dp[K - 1] = 1.0 * Math.min(N - K + 1, W) / W;
        // K - 1 的结果已经有了，从K -2 开始逐步计算
        // d(x) = d(x+1) - (d(x+w+1) - d(x+1))/W
        for (int i = K - 2; i >= 0; i--) {
            dp[i] = dp[i + 1] - (dp[i + W + 1] - dp[i + 1]) / W;
        }
        return dp[0];
    }
}


// 超时
// 时间复杂度 O(N+KW)，当K远小于N的情况
/* class Solution {
    public double new21Game(int N, int K, int W) {
        if (K == 0) {
            return 1.0;
        }
        // 表示最大计算范围，第一个元素为0是整体的概率，本身是后面概率的平均值
        // Double初始化为null， 而double初始化为0.0
        double[] dp = new double[K+W];
        for (int i = K; i <= N && i < K+W; i++) {
            dp[i] = 1.0;
        }
        for (int i=K-1; i >= 0; i--) {
            for (int j=1; j<=W; j++) {
                // 这样也就是平均值
                dp[i] += dp[i+j] / W;
            }
        }
        return dp[0];
    }
} */
// @lc code=end

